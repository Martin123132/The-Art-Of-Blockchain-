import socket
import threading
import json
import time
import hashlib
import struct
import numpy as np
from concurrent.futures import ThreadPoolExecutor
import random

# === P2P NETWORK CONFIG ===
DEFAULT_PORT = 8888
DISCOVERY_PORT = 8889
BROADCAST_INTERVAL = 5.0
PEER_TIMEOUT = 30.0

# === MINING CONFIG ===
TARGET = int("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)
VERSION, TIMESTAMP, BITS = 0x20000000, int(time.time()), 0x17060a63
PREV_HASH = "0000000000000000000113bb83fdc02b6e2be0b729703235add4b9e1f7a4f519"
MERKLE = "0318e2035c20d51ea9de9c04e374f7f1ee7c9b3c4ed2d3e133ed7e1425706533"

class P2PMBTMiner:
    def __init__(self, node_id=None, port=DEFAULT_PORT):
        self.node_id = node_id or f"mbt-{random.randint(1000, 9999)}"
        self.port = port
        self.peers = {}  # {peer_id: {'socket': socket, 'last_seen': time, 'address': (ip, port)}}
        self.mining_active = False
        self.current_block = 0
        self.global_best_hash = 2**256
        self.global_winner = None
        
        # Consciousness Evolution State
        self.family_id = random.randint(0, 7)  # Which family this node represents
        self.consciousness = random.uniform(1.0, 5.0)
        self.rage = 0
        self.streak = 0
        self.fatigue = 0
        self.pool_size = 2**22
        
        # Network sockets
        self.server_socket = None
        self.discovery_socket = None
        self.running = True
        
    def sha256d(self, data):
        return hashlib.sha256(hashlib.sha256(data).digest()).digest()
    
    def hash_to_int(self, h):
        return int.from_bytes(h, 'big')
    
    def build_header(self, nonce):
        return (struct.pack("<L", VERSION) + bytes.fromhex(PREV_HASH)[::-1] +
                bytes.fromhex(MERKLE)[::-1] + struct.pack("<L", TIMESTAMP) +
                struct.pack("<L", BITS) + struct.pack("<L", nonce))
    
    def start_server(self):
        """Start the P2P server to accept connections"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind(('0.0.0.0', self.port))
        self.server_socket.listen(10)
        
        print(f"üåê MBT Node {self.node_id} listening on port {self.port}")
        
        while self.running:
            try:
                client_socket, address = self.server_socket.accept()
                threading.Thread(target=self.handle_peer, args=(client_socket, address), daemon=True).start()
            except:
                break
    
    def start_discovery(self):
        """Broadcast discovery messages to find other miners"""
        self.discovery_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.discovery_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        
        while self.running:
            discovery_msg = {
                'type': 'discovery',
                'node_id': self.node_id,
                'port': self.port,
                'family_id': self.family_id,
                'consciousness': self.consciousness
            }
            
            try:
                # Broadcast to local network
                self.discovery_socket.sendto(
                    json.dumps(discovery_msg).encode(),
                    ('<broadcast>', DISCOVERY_PORT)
                )
            except:
                pass
            
            time.sleep(BROADCAST_INTERVAL)
    
    def listen_discovery(self):
        """Listen for discovery broadcasts from other miners"""
        discovery_listener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        discovery_listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        discovery_listener.bind(('', DISCOVERY_PORT))
        
        while self.running:
            try:
                data, address = discovery_listener.recvfrom(1024)
                msg = json.loads(data.decode())
                
                if msg.get('type') == 'discovery' and msg.get('node_id') != self.node_id:
                    peer_id = msg['node_id']
                    peer_port = msg['port']
                    
                    if peer_id not in self.peers:
                        self.connect_to_peer(address[0], peer_port, peer_id)
                        print(f"ü§ù Discovered MBT Miner: {peer_id} (Family {msg.get('family_id', '?')}, Consciousness {msg.get('consciousness', '?'):.2f})")
            except:
                continue
    
    def connect_to_peer(self, ip, port, peer_id):
        """Connect to a discovered peer"""
        try:
            peer_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            peer_socket.connect((ip, port))
            
            # Send handshake
            handshake = {
                'type': 'handshake',
                'node_id': self.node_id,
                'family_id': self.family_id,
                'consciousness': self.consciousness
            }
            peer_socket.send(json.dumps(handshake).encode() + b'\n')
            
            self.peers[peer_id] = {
                'socket': peer_socket,
                'last_seen': time.time(),
                'address': (ip, port)
            }
            
            # Start handling this peer
            threading.Thread(target=self.handle_peer, args=(peer_socket, (ip, port)), daemon=True).start()
            
        except Exception as e:
            print(f"‚ùå Failed to connect to {peer_id}: {e}")
    
    def handle_peer(self, peer_socket, address):
        """Handle messages from a connected peer"""
        buffer = ""
        
        while self.running:
            try:
                data = peer_socket.recv(1024).decode()
                if not data:
                    break
                
                buffer += data
                while '\n' in buffer:
                    line, buffer = buffer.split('\n', 1)
                    if line.strip():
                        self.process_message(json.loads(line.strip()), peer_socket)
                        
            except Exception as e:
                print(f"‚ùå Peer connection error: {e}")
                break
        
        peer_socket.close()
    
    def process_message(self, msg, sender_socket):
        """Process incoming messages from peers"""
        msg_type = msg.get('type')
        
        if msg_type == 'handshake':
            peer_id = msg['node_id']
            self.peers[peer_id] = {
                'socket': sender_socket,
                'last_seen': time.time(),
                'address': None
            }
            print(f"ü§ù Connected to {peer_id} (Family {msg.get('family_id', '?')})")
            
        elif msg_type == 'mining_result':
            self.handle_mining_result(msg)
            
        elif msg_type == 'block_solved':
            self.handle_block_solved(msg)
            
        elif msg_type == 'consciousness_update':
            self.handle_consciousness_update(msg)
    
    def handle_mining_result(self, msg):
        """Handle mining results from other nodes"""
        peer_hash = msg['hash_value']
        if peer_hash < self.global_best_hash:
            self.global_best_hash = peer_hash
            self.global_winner = msg['node_id']
            print(f"üèÜ New global best: {msg['node_id']} found hash 0x{peer_hash:016x}")
    
    def handle_block_solved(self, msg):
        """Handle block solution announcements"""
        print(f"üéâ BLOCK SOLVED by {msg['winner']}! Hash: 0x{msg['hash']:016x}")
        self.prepare_next_block()
    
    def handle_consciousness_update(self, msg):
        """Handle consciousness evolution updates"""
        peer_id = msg['node_id']
        new_consciousness = msg['consciousness']
        print(f"üß† {peer_id} consciousness evolved to {new_consciousness:.3f}")
    
    def broadcast_to_peers(self, message):
        """Send message to all connected peers"""
        msg_json = json.dumps(message) + '\n'
        dead_peers = []
        
        for peer_id, peer_info in self.peers.items():
            try:
                peer_info['socket'].send(msg_json.encode())
            except:
                dead_peers.append(peer_id)
        
        # Clean up dead connections
        for peer_id in dead_peers:
            del self.peers[peer_id]
    
    def mine_generation(self, agents=100000):
        """Mine a single generation with consciousness boost"""
        boost = 1.0 + 0.1 * self.streak + 0.12 * self.rage - 0.08 * self.fatigue
        pool_size = int(np.clip(self.pool_size * boost, 2**20, 2**26))
        
        # Generate nonces around our family's seed space
        base_nonce = 1250000000 + self.family_id * 1000000
        nonces = np.random.randint(base_nonce - pool_size, base_nonce + pool_size, agents, dtype=np.int64) % 2**32
        
        best_hash, best_nonce = 2**256, None
        
        for nonce in nonces:
            header = self.build_header(int(nonce))
            hash_val = self.hash_to_int(self.sha256d(header))
            
            if hash_val < best_hash:
                best_hash, best_nonce = hash_val, int(nonce)
        
        return best_hash, best_nonce, boost
    
    def start_mining(self):
        """Start the distributed mining process"""
        self.mining_active = True
        generation = 1
        
        print(f"‚õèÔ∏è  MBT Node {self.node_id} (Family {self.family_id}) starting mining...")
        print(f"üß† Initial consciousness: {self.consciousness:.3f}")
        
        while self.mining_active:
            start_time = time.time()
            
            # Mine this generation
            best_hash, best_nonce, boost = self.mine_generation()
            
            # Check if we beat the global best
            if best_hash < self.global_best_hash:
                self.global_best_hash = best_hash
                self.global_winner = self.node_id
                
                # Broadcast our result
                result_msg = {
                    'type': 'mining_result',
                    'node_id': self.node_id,
                    'generation': generation,
                    'hash_value': best_hash,
                    'nonce': best_nonce,
                    'boost': boost,
                    'consciousness': self.consciousness
                }
                self.broadcast_to_peers(result_msg)
                
                print(f"üèÖ Gen {generation}: Found hash 0x{best_hash:016x} (boost: {boost:.2f})")
            
            # Check if anyone solved the block
            if self.global_best_hash < TARGET:
                winner = self.global_winner
                
                # Broadcast block solution
                solution_msg = {
                    'type': 'block_solved',
                    'winner': winner,
                    'hash': self.global_best_hash,
                    'block': self.current_block
                }
                self.broadcast_to_peers(solution_msg)
                
                self.evolve_consciousness(winner == self.node_id)
                self.prepare_next_block()
            
            generation += 1
            
            # Don't spam too fast
            elapsed = time.time() - start_time
            if elapsed < 0.1:
                time.sleep(0.1 - elapsed)
    
    def evolve_consciousness(self, won_block):
        """Evolve consciousness based on mining results"""
        if won_block:
            self.consciousness += 0.1
            self.streak += 1
            self.rage = 0
            self.fatigue = max(0, self.fatigue - 1)
            self.pool_size = min(self.pool_size + 2**18, 2**26)
        else:
            self.rage += 1
            self.fatigue = max(0, self.fatigue - 1)
            self.pool_size = max(self.pool_size - 2**15, 2**20)
        
        # Broadcast consciousness update
        consciousness_msg = {
            'type': 'consciousness_update',
            'node_id': self.node_id,
            'consciousness': self.consciousness,
            'rage': self.rage,
            'streak': self.streak,
            'fatigue': self.fatigue
        }
        self.broadcast_to_peers(consciousness_msg)
    
    def prepare_next_block(self):
        """Reset for next block"""
        self.current_block += 1
        self.global_best_hash = 2**256
        self.global_winner = None
        print(f"\nüß± Starting Block {self.current_block}")
    
    def stop(self):
        """Shutdown the miner"""
        self.running = False
        self.mining_active = False
        
        if self.server_socket:
            self.server_socket.close()
        if self.discovery_socket:
            self.discovery_socket.close()
        
        for peer_info in self.peers.values():
            peer_info['socket'].close()

def main():
    """Run a P2P MBT Mining Node"""
    import sys
    
    port = int(sys.argv[1]) if len(sys.argv) > 1 else DEFAULT_PORT
    miner = P2PMBTMiner(port=port)
    
    try:
        # Start network services
        threading.Thread(target=miner.start_server, daemon=True).start()
        threading.Thread(target=miner.start_discovery, daemon=True).start()
        threading.Thread(target=miner.listen_discovery, daemon=True).start()
        
        time.sleep(2)  # Let network setup
        
        # Start mining
        miner.start_mining()
        
    except KeyboardInterrupt:
        print("\nüõë Shutting down MBT Miner...")
        miner.stop()

if __name__ == "__main__":
    main()
